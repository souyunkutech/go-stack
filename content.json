{"pages":[{"title":"关于我们","text":"简介「 Go技术栈 」是 「 搜云库技术团队 」独立运营的一个专注于Go技术栈的研究与知识分享的网站，网站覆盖 Golang、前端、后端、区块链、容器化编程、分布式的Golang微服务编程、等技术栈，助力您成为有思想的Golang架构师，聊架构，聊职场、聊人生！ 联系我们邮箱：gostack@souyunku.com 关注我们的「微信公众号」","link":"/about/index.html"}],"posts":[{"title":"资料索引","text":"中文社区 Go技术栈：个专注于Go技术栈的研究与知识分享的网站 Golang 中国：国内较早的 Go 社区，汇聚各类信息与服务 Study Golang：国内 Go 社区先驱，同样汇聚各类信息与服务 Revel 交流论坛：Revel 框架的中文社区 GoCN Forum：Go 语言爱好者中文交流论坛 英文社区 Go Forum：Go 语言爱好者英文交流论坛 golang-nuts 邮件列表：Go 语言官方指定邮件列表讨论区 Go+ 社区：Go 语言官方指定 G+ 社区 知识图谱 Go Knowledge Graph：Go 知识图谱 [推荐] 资料汇总官方文档 英文文档 中文文档 标准库中文版 Go指南 中文资料书籍： 《深入解析Go》 《Go实战开发》 《Go入门指南》 《Go语言标准库》 《Go Web 编程》 《Go语言博客实践》 《Go语言学习笔记》 教程： 《Go编程基础》 《Go Web基础》 《Go名库讲解》 《Go 命令教程》 翻译： 《Effective Go》 英文版 《The Way to Go》 中文版 《Learning Go》 中文版 《Learning Go》 英文版=&gt;中文版 关注我们的「微信公众号」","link":"/2019/04/06/data-index/"},{"title":"【跟着我们学Golang】Go语言全平台安装","text":"学习Go语言的第一步当然是要先安装Go语言的环境，毕竟，没有这个环境咱们什么都做不了。但是在安装环境之前咱们先了解一下Go涉及到的环境变量。这里介绍几个比较常用的Go语言环境变量。 GOROOTGo的安装路径，windows默认安装在’c:/go’路径下，Linux/macos下默认安装在’~/go’路径下 GOPATHGo 语言源码文件、包文件和可执行文件的路径，换句话说，GOPATH指定的是存放项目相关的文件路径 GOOS电脑的操作系统标识。如Mac下为“darwin“，windows下为”windows“ GOARCH电脑的处理器架构，如386，arm或amd64 GOBIN编译文件的安装位置，默认$GOROOT/bin 下面开始今天的正题，安装Go环境 Go语言的安装过程跟Java安装的过程非常的类似，可以通过二进制发行版安装、源码安装、安装程序以及第三方工具进行安装比较常用的方式有通过二进制发行版安装、安装程序安装和第三方工具安装三种方式。源码安装需要各种各样的编译环境，所以动手能力不强以及兴趣不高的同学可以采用其他三种方式 官方下载路径Go语言是Google内部开发开源出来的语言，所以，官方网站：https://golang.org 同样由Google提供但是这个官方网站对国内的用户却不是那么友好，好在Google提供了国内能够访问的国内官网地址：https://go-zh.org/ 供国内用户使用一些Go语言想关的资料都可以从这里查到。但是该网站却没有提供下载链接，只是提供了下载网页的外链。所以咱们让然使用golang.cn域名下提供的下载链接 下载路径为 : https://golang.google.cn/dl/ 这里咱们只介绍通过二进制发行版、安装程序和第三方工具安装三种常用的方式，动手能力比较强的可以尝试着通过源码进行安装 通过二进制发行版安装Windows平台这里以64位操作系统举例 go最新版1.12.4下载链接：https://dl.google.com/go/go1.12.4.windows-amd64.zip 下载之后我们将其解压到默认的安装路径’C:\\go’目录下之后打开控制面板配置环境变量，将’C:\\go\\bin;’加入到Path的最前面，确定退出环境变量设置窗口。(如果环境变量不生效，可以尝试一下重启大法^_^) 在重新打开一个cmd终端，输入’go’,如果看到类似下面的内容，就说明安装成功啦，不相信的话可以执行下文的’hello world’。如果发现其他的，说明没有安装成功，可以检查一下环境变量的问题 123456789101112131415161718192021222324252627282930313233343536373839Go is a tool for managing Go source code.Usage: go command [arguments]The commands are: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packagesUse &quot;go help [command]&quot; for more information about a command.Additional help topics: c calling between Go and C buildmode description of build modes filetype file types gopath GOPATH environment variable environment environment variables importpath import path syntax packages description of package lists testflag description of testing flags testfunc description of testing functionsUse &quot;go help [topic]&quot; for more information about that topic. Linux 平台这里以64位操作系统举例 go最新版1.12.4下载链接:https://dl.google.com/go/go1.12.4.linux-amd64.tar.gz 先将下载好的二进制发行版压缩包放解压到用户根目录，此时根目录中将会出现’go’文件夹，里面就是go所有的安装内容 linux下配置环境变量也相对简单一些 将以下命令添加到 $HOME/.profile 文件中执行一下’source $HOME/.profile’就可以了 1export PATH=$PATH:$HOME/go/bin 配置好环境变量，我们再输入’go’，出现上面成功的说明，即安装成功了 Mac平台通过二进制发行版安装的方式与Linux平台基本相同，下载二进制发行版压缩包，解压到用户根目录，配置环境变量。不过要注意下载Mac版本的安装包来安装哦 这里需要注意的是，咱们通过通过二进制发行版来安装的过程中均没有配置’GOROOT’,’GOPATH’等环境变量。这是因为咱们在安装的过程中，都是将Go安装在默认的位置，Windows的默认位置是’C:\\go’, MacOS和Linux的默认位置是’$HOME/go’。所以’GOROOT’使用的就是默认路径，’GOPATH’同样采用的是默认路径（用户的根目录），所以这里都是没问题的 第三方工具Mac平台和Linux平台的用户都会使用包管理器进行程序的管理，Windows平台好像并没有（如果有的话可以留言告知）Go语言同样可以通过包管理器进行安装，也是非常的方便 apt-getUbuntu是目前使用最多的Linux桌面系统，使用apt-get命令来管理软件包 我们可以通过下面的命令来安装Go 1sudo apt-get install golang 这里需要注意的是，apt提供的不是最新的Go版本，而且，直接通过’apt-get install golang’下载的go，版本可能还比较低，这时候咱们可以指定版本下载 1sudo apt-get install golang-1.10 Ubuntu16.04中 apt-get提供的最新的Go版本为1.10，不是Go发行的最新版，如果需要安装最新版，可参考其他安装方式 homebrewhomebrew是Mac系统下面目前使用最多的管理软件的工具，简称brew 目前brew已支持Go，可以通过命令直接安装Go 如果没有安装过brew可以参考brew官方文档：https://brew.sh 这里直接通过brew进行Go的安装，不再阐述brew的安装 12brew update &amp;&amp; brew upgradebrew install go 安装程序Windows和MacOS作为全球最大的桌面系统，Go同样提供了安装程序来帮助开发者，这样一来只需要通过鼠标进行简单的点击就能很快的安装好Go的环境 如果想通过这种方式进行安装，可以直接下载对应的安装程序点击运行即可 测试安装环境安装完成了，下面就可以进入咱们大家最熟悉的’Hello World’了 可以先将下面的内容拷贝到main.go的文档中，运行’go run main.go’测试。后续咱们再细聊该文件的结构1234567package mainimport &quot;fmt&quot;func main() { fmt.Println(&quot;Hello World&quot;)} 如果程序能正常运行，并正确输出’Hello World’，那恭喜你，Go语言环境安装已经成功了 关注我们的「微信公众号」 首发微信公众号：Go技术栈，ID：GoStack 版权归作者所有，任何形式转载请联系作者。 作者：搜云库技术团队出处：https://gostack.souyunku.com/2019/04/15/install-golang","link":"/2019/04/15/install-golang/"},{"title":"跟着我们学Golang","text":"「搜云库技术团队」从事于Java相关领域多年，拥有Java语言技术丰富的从业经验，涉猎AI、Python、Java、Android、iOS、Golang、前端、后端、大数据、人工智能等，我们的目标也是致力于营造一个覆盖全栈的学习分享的技术社群。区块链、云计算以及微服务等技术近年来风靡全球，现如今如果说不知道区块链是什么的人，在这个行业中的感觉都会比人家低人一等。大家所熟知的公有链以太坊、联盟链Hyperledger Fabric，甚至是云计算必用的容器化技术docker，都是使用Go语言来实现的。 借着这股技术浪潮，我们新开「Go技术栈」这个公众号，目的在于分享Go语言相关领域的学习过程，让更多的人能够了解区块链、云计算、微服务等前沿技术并能对其有一定程度的认知与掌握。能够向更高薪的岗位挑战。 关注我们能获得什么「Go技术栈」不仅仅包含丰富的书籍和清晰明了的学习路线，内容丰富的4T学习资源视频，还有多个微信技术交流群（近4000人），供大家进行技术讨论，无论有没有相关经验都能轻松驾驭新技术。 一线城市的工作内推群、北、上、广、深、杭、成、武、南、郑、西，工作内推群，帮助大家找到理想的工作，来体现各位的价值。 关注我们，不仅能利用有限的时间学习无限的知识，还能在通往高薪未来的道路上少走弯路。 公号后台回复关键字： 「1024」可获得 4T 学习资源视频 「2048」可获得 Golang 学习路线 「内推」 可进群 一线城市内推群 公众号的目标读者人群人生充满迷茫的小白不知道如何选择，又想要获得高薪？如果你自制力强、学习态度好、又能坚持，那「Go技术栈」非常适合你，我们会为你提供由浅入深的学习计划，小到Go工具集，大到区块链、云计算，我们都会涉及到。 有一定经验的开发工程师有一定的开发经验，或许技术发展受限，想着多学习一门技术拓宽自己的未来发展，看好区块链、云计算等热门行业。那么选择「Go技术栈」，说明你找对地方了。 运维人员常年从事运维工作，整天与服务器打交道，想着学习开发。那简直太好了，「Go技术栈」会涉及到容器化技术相关的知识，又会从基础做起。做运维开发，没问题。 志向远大的全能型人才听说你想独立开发，自己搞定前端后端运维等一整套的工作？那Go语言简直太适合你了。偷偷告诉你，「Go技术栈」，这些技术都会涵盖到。 加油吧少年就这么多？不，Go语言能做的还很多。「Go技术栈」能做的也很多。 漫漫学习路，搜云库技术团队愿与您携手同行，踏向征服Go语言的仕途。 关注我们的「微信公众号」","link":"/2019/04/11/study-golang-with-us/"},{"title":"【跟着我们学Golang】流程控制","text":"作为一门高级语言，Go同样提供了流程控制的支持。在了解了基础结构之后，继续学习Go的流程控制，里面涉及到的基础结构的内容还能对其有更多的了解。 说流程控制之前先说一下interface，因为后续在流程控制中会穿插着对interface的使用。 interfaceinterface是一切类型的基类型，类似于Java中的基类Obejct，所有的结构都是interface的实现，因为interface基类型没有定义任何的函数，所以其他任何结构都认为是interface的实现。当然，也可以自己定义interface自己去实现相应的函数，这个下期面向对象的时候会详细解释。这里先简单说明interface作为基类型时的使用。 在Java中，所有的类型都是Object的子类，所以声明对象时可以将对象的类型声明为Object，在赋值时给一个子类型，在Go中同样可以，但仅限于针对interface声明的使用（还是会牵涉到面向对象的东西），也就是说，声明时可以将变量声明为interface类型，赋值时给一个其他基础类型的值，这是最简单的interface作为基类型的使用。 123var hello interface{} = &quot;hello world&quot;fmt.Println(hello) 例子中声明hello时，声明的类型是interface{}类型，并不是string类型，但是赋值时给的是string类型，说明hello实际类型还是string类型。具体的类型转换下面会详细说明。 if-elseGo中的if-else结构的用户与Java中的特别的类似，仅仅区别在两者的语法上面，Go的语法为： 1234567if 条件1 { ...} else if 条件2 &amp;&amp; 条件3 { ...} else { ...} Go对语法的要求没有Java那么严格，对于括号可以带，也可以不带。同样的，Go也支持&amp;&amp;、||、!这样的运算符进行多个条件的关联判断 1234567891011func max(a, b int) (max int) { if a &gt; b { max = a } else if a == b { max = a } else { max = b } return } 断言断言在Go中是一种类型转换的语法，能否方便的进行类型的转换。Go语言中简单的断言语法为 value := element.(type) 123456//value := element.(type) //type为要转换的类型var hello interface{} = &quot;helloworld&quot;fmt.Println(hello.(string))fmt.Println(hello.(int))//该行会报错，因为hello实际类型是string类型 稍微不注意，直接转换的话就会出现异常，所以一般不推荐使用简单的语法，而是用高级语法 value, ok := element.(type)，这也是在if-else结构中讲解的原因。 12345678910// value, ok := element.(type) //type为要转换的类型，ok为是否成功转换，类型为bool，value为实际转换的值var hello interface{} = &quot;helloworld&quot;helloS, ok := hello.(string)if ok { fmt.Println(&quot;hello tranfer successfully : &quot;, helloS)} else { fmt.Println(&quot;hello transfer failed&quot;)} 使用高级语法能保证在运行的时候不会出现错误，保证程序的持续执行，这是比较推荐的做法。 map断言是map的一种高级用法。 1234567891011//map的断言// value, ok := m[key] //这里的OK不再是简单的成功或者失败，理解成是否存在更合适var m = make(map[string]interface{})//创建map的方式，具体make的用法后续会讲解m[&quot;key1&quot;] = &quot;value1&quot;value1, ok := m[&quot;key1&quot;]if ok { fmt.Println(&quot;map m contain &apos;key1&apos; &quot;, value1)} else { fmt.Println(&quot;map m contain &apos;key1&apos;&quot;)} map在断言的使用上好像是天生支持似的，不需要进行Contains函数的校验等，直接使用，平时在代码中使用的也是非常多。简直不要太好用。 switchswitch感觉像是if-else的高级版，同样是进行条件判断的结构，不同的条件执行不同的语句。语法类似Java，Java中只能使用byte、int、short、char和string，在Go中可没有这些限制。从上至下的判断，直到找到匹配的case或者执行default语句，case结尾也不需要break进行跳出流程操作，执行完自动跳出。相反，如果想执行下一个case的话，需要使用fallthrough关键字进行下沉操作，这时候下一条case的条件将被忽略。 12345678switch value1 { //大括号必须与switch保持一行 case value1: ... case value2, value3://多个条件使用逗号隔开 ... default://没有符合的条件执行默认 ...} 语法规定 switch后跟的value1可以是任意类型（甚至是不写），但是case后的条件必须和switch后的value保持相同类型 12345678910111213141516171819202122232425262728grade := 10switch grade {//case code &lt; 60://code为int类型，不能使用code &lt; 60作为case条件case 10: fmt.Println(&quot;不及格&quot;)case 70: fmt.Println(&quot;及格&quot;)default: fmt.Println(&quot;无效的分数&quot;)}//用于类型断言switch hello.(type) {case string: fmt.Println(&quot;hello is string&quot;)case int: fmt.Println(&quot;hello is int&quot;)default: fmt.Println(&quot;hello is unknown type&quot;)}switch {//直接判断casecase a &lt; b: fmt.Println(&quot;a less than b&quot;) fallthrough //紧接着执行下一个case，不需要进行判断case a &gt; b: fmt.Println(&quot;a bigger than b&quot;)} for说到循环、重复执行等首先想到的就是for，Go同样提供了支持，相对于Java，Go中for的使用更灵活。同样的，想跳出for循环时使用break关键字。 1234567891011121314151617181920//语法一for init;条件;赋值{//左侧大括号必须与for同行 ...}//语法二for 条件 {//左侧大括号必须与for同行 ...}//语法三//这是个死循环for {//左侧大括号必须与for同行 ...}//语法四for index, value := range slice/array/map {//range是关键字 ...} 上手就是一个排序来介绍最基本的for结构 12345678910a := []int{1, 3, 9, 4, 1, 4, 6, 132, 1, 29, 43, 55, 89, 46}for i := 0; i &lt; len(a); i++ {//len为Go内置函数 for j := i + 1; j &lt; len(a); j++ { if a[i] &gt; a[j] { a[i], a[j] = a[j], a[i] } }}fmt.Println(a)//结果：[1 1 1 3 4 4 6 9 29 43 46 55 89 132] 只写条件的for循环，类似Java中的while 12345var i = 0for i &lt; len(a) { fmt.Print(a[i],&quot; &quot;) i++}//结果： 1 1 1 3 4 4 6 9 29 43 46 55 89 132 死循环写法更简单了，不过需要注意使用break进行跳出，否则电脑就该嗡嗡嗡～响不停了 123456789i = 0for{ if i &lt; len(a) { fmt.Print(a[i], &quot; &quot;) i++ } else { break }}//结果： 1 1 1 3 4 4 6 9 29 43 46 55 89 132 最牛的语法四就是为slice和array使用的，能遍历所有的集合。当遍历slice和array时，index指的是其中的索引位置；遍历map时指的就是key了。请看下面的例子1234567891011121314151617181920212223242526272829303132for index, value := range a { fmt.Printf(&quot;index: %d, value: %d \\n&quot;, index, value)}/*结果：index: 0, value: 1index: 1, value: 1index: 2, value: 1index: 3, value: 3index: 4, value: 4index: 5, value: 4index: 6, value: 6index: 7, value: 9index: 8, value: 29index: 9, value: 43index: 10, value: 46index: 11, value: 55index: 12, value: 89index: 13, value: 132 */m := map[string]string{}m[&quot;hello&quot;] = &quot;world&quot;m[&quot;hey&quot;] = &quot;bye&quot;for key, value := range m { fmt.Printf(&quot;key: %s, value: %s \\n&quot;, key, value)}/*结果：key: hello, value: worldkey: hey, value: bye */ selectselect 第一眼看到可能会想到SQL中的选择，但是它也是Go中的一个流程控制关键字。 select的使用主要是结合channel来使用，所以这里要是讲解channels会设计到很多东西，我们后期会做详细的讲解，这里先做select的介绍。 select的语法跟switch类似，用于选择合适的条件进行执行相应的逻辑，但牵涉到channel，所以select中的case都是对channel的操作，只能是往channel中读或者写。 12345678select { case channel读操作: ... case channel写操作: ... default: ...} 注意点： channel包含读和写两种操作，case中必须包含一种操作 case的执行是无序的、随机的，select会执行任意一个可执行的case 没有可执行的case时会执行default，没有default的话就会阻塞，等待可执行的channel 下面是一个简单的例子实现，先不要深究内容含义，了解select语法即可 12345678910c := make(chan int, 1)select {case c &lt;- 1: fmt.Println(&quot;push into channel&quot;)case &lt;-c: fmt.Println(&quot;get from channel&quot;)default: fmt.Println(&quot;default&quot;)}//结果：push into channel …不要怀疑标题，标题就是三个英文点，这里要说一下这三个点的问题，以此来解释一下为什么在使用fmt.Println()和fmt.Printf()函数时使用逗号将参数隔开的问题。 我们先看一下fmt.Println()和fmt.Printf()的源码 123456789101112// Println formats using the default formats for its operands and writes to standard output.// Spaces are always added between operands and a newline is appended.// It returns the number of bytes written and any write error encountered.func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...)}// Printf formats according to a format specifier and writes to standard output.// It returns the number of bytes written and any write error encountered.func Printf(format string, a ...interface{}) (n int, err error) { return Fprintf(os.Stdout, format, a...)} 这里看到Println()和Printf()这两个函数其实就一个入参，为什么我能用逗号分隔从而给多个参数呢？ 原因是这样的，a ...interface{}这个其实是slice的一个特殊用法，说明这定义的是一个可变参数，可以接收不定数量的统一类型的参数，定义为…interfaec{}就可以接收不定数量的任意基础类型。定义可变参数时的语法就是在类型前面加上这三个点，这里使用interface就说明可以接收任何类型 想使用这可变参数的语法也很简单，可以将其作为slice使用，也可以继续将其作为可变参数使用。使用可变参数的语法就是在定义的后面加上这三个点。下面看例子 123456789101112131415161718192021222324252627func main(){ definedThreeDot(&quot;jack&quot;, &quot;rose&quot;, &quot;tom&quot;, &quot;jerry&quot;)//定义多个参数来使用可变参数}func definedThreeDot(source ...string) {//定义可变参数，定义时在类型前面加上三个点 useThreeDot(source...)//将可变参数作为可变参数使用，使用时在定义后面加上三个点 useThreeDotAsSlice(source)//将可变参数作为slice使用}func useThreeDotAsSlice(ss []string) {//定义slice来接收可变参数 fmt.Println(ss)//直接打印slice}func useThreeDot(ss ...string) {//定义可变参数，定义时在类型前面加上三个点 for index, s := range ss {//作为slice来遍历可变参数 fmt.Printf(&quot;index : %d, value : %s \\n&quot;, index, s)//index和s都作为可变参数来使用 }}/*结果：index : 0, value : jack index : 1, value : rose index : 2, value : tom index : 3, value : jerry [jack rose tom jerry]*/ 总结Go 中的流程控制大致上就这么多，平时项目中使用的也是非常多的，特别是对便利集合时，非常的方便。相信你亲自体验后也会赞不绝口的。 同时也顺带解释了一下可变参数，结合着slice和流程控制也能对这个可变参数有一个更深的了解。 源码可以通过’github.com/souyunkutech/gosample’获取。 关注我们的「微信公众号」 首发微信公众号：Go技术栈，ID：GoStack 版权归作者所有，任何形式转载请联系作者。 作者：搜云库技术团队出处：https://gostack.souyunku.com/2019/04/29/if-for-switch-select","link":"/2019/04/29/if-for-switch-select/"},{"title":"【跟着我们学Golang】基础结构","text":"鉴于上篇文章我们已经讲过Go语言环境的安装，现在我们已经有了一个可以运行Go程序的环境，而且，我们还运行了’Hello World’跑出了我们的第一个Go程序。这节我们就以’Hello World为例，讲解Go的基础结构，详细的解释一下Hello World中的每一行都代表了什么。 Go语言是一门静态语言，在编译前都会对代码进行严格的语法校验，如果语法错误是编译不过去的，所以基础结构是非常重要的一个环节。 类似Java中的package、class、interface、函数、常量和变量等，Go也有package、struct、interface、func、常量、变量等内容。 struct类似Java中的class，是Go中的基本结构题。interface也类似Java中的接口，可定义函数以供其他struct或func实现（可能不太好理解，后面会讲）。 这里我们按照由外而内，从上至下的的顺序进行讲解。 GOPATH上节说到GOPATH指定了存放项目相关的文件路径，下面包含’bin’、’pkg’、’src’三个目录。 1.src 存放项目源代码 2.pkg 存放编译后生成的文件 3.bin 存放编译后生成的可执行文件 目录结构如下 12345678910GOPATH \\_ src \\_ projectA \\_ projectB \\_ pkg \\_ projectA \\_ projectB \\_ bin \\_ commandA \\_ commandB src目录是我们用的最多的，因为我们所有的项目都会放到这个目录中。后续项目的引用也是相对于该目录。 文件名一个Go文件，我们对其的第一个认识，就是其的后缀，Go文件以‘.go’结尾（Windows用户一定要文件后缀的问题），这个很容易理解。不能以数字开头、不能包含运算符、不能使用Go的关键字等对比其他语言也非常容易理解。有效的标识符必须以字母（可以使用任何 UTF-8 编码的字符或 _）开头加上任意个数字或字符，如：’hello_world.go’、’router.go’、’base58.go’等。 Go天然支持UTF8 不过在这里有一些细节需要注意，就是Go文件在命名的时候，跟其他语言不太一样。Go文件都是小写字母命名(虽然大写也支持，但是大写文件名并不规范)，如果需要多个单词进行拼接，那单词之间以_下划线进行连接。特别是编写测试用例和多平台支持时对Go文件的命名。如：’math_test.go’、’cpu_arm.go’、’cpu_x86.go’等。 命名规范Go可以说是非常干净整洁的代码，所以Go的命名非常简洁并有意义。虽然支持大小写混写和带下划线的命名方式，但是这样真的是非常的不规范，Go也不推荐这样做。Go更喜欢使用驼峰式的命名方式。如’BlockHeight’、’txHash’这样的定义。另外Go的定义可以直接通过’package.Xxx’这样的方式进行使用，所以也不推荐使用GetXXX这样的定义。 packagepackage的存在，是为了解决文件过多而造成的絮乱等问题，太多的文件都放在项目根目录下看着总是让人觉得不舒服，对开发、后期维护等都是问题。 作为代码结构化方式之一， 每个Go程序都有package的概念。 Go语法规定 每个Go文件的第一行（不包含注释）都必须是package的定义 可执行的程序package定义必须是main package默认采用当前文件夹的名字，不采用类似Java中package的级联定义 如下面的代码指定该文件属于learning_go这个package。 123package learning_go... Go对package的定义并不严格，在文件夹下的Go文件可以不使用文件夹名称作为package的定义（默认使用），但是同一个文件夹下的所有Go文件必须使用同一个package定义，这个是严格要求的。 tips： package的定义均应该采用小写字母，所以文件夹的定义也应该都是小写字母。 为了更好的区分不同的项目，Go定义的项目结构中都包含开源站点的信息，如github、gitee等开源站点中的所有开源Go项目都可以直接拿来使用。 Go的背后是所有开源世界 拿在GitHub下面创建的Go项目gosample项目为例。其项目路径为：”github.com/souyunkutech/gosample”。”github.com”表示其开源站点信息。”souyunkutech/gosample”就是项目的名称。文件的路径就对应为”$GOPATH/src/github.com/souyunkutech/gosample”。 “souyunkutech”表示了gosample这个项目属于”souyunkutech”这个用户所有。 package的获取在引用某个项目之前，需要先获取其源码，将其放置到$GOPATH/src下，这样我们才能对其进行引用从而正确的进行编译。 Go获取源码可以手动将源码根据其相对路径放到正确的路径下，也可以通过go get path的方式自动获取。 如获取’gosample’项目，可以通过git clone的方式下载到$GOPATH/src/github.com/souyunkutech/ 也可以通过go get github.com/souyunkutech/gosamp的方式进行获取，go会自己把项目方到$GOPATH/src/github.com/sirupsen/目录下。 如获取Go语言中一个非常知名的第三方日志组件logrus，可以将其通过git clone的方式下载到$GOPATH/src/github.com/sirupsen/ 也可以通过go get github.com/sirupsen/logrus的方式进行获取。 package的引用import关键字的作用就是package的引用。作为外部引用的最小单位，Go以package为基础，不像Java那样，以对象为基础，供其他程序进行引用，import引用了某个package那就是引用了这个package的所有（可见的）内容。 语法上需要注意的就是在引用时需要双引号包裹。没有使用过的package引用要不删除，要不定义为隐式引用。否则的话，在运行或者编译程序的时候就会报错：imported and not used:… 如HelloWorld代码中引用的’fmt’就是Go语言内建的程序package。fmt这个package下包含’doc.go’、’format.go’等（这个可以通过IDE的方式进行查看）这些Go文件中所有的（可见的）内容都可以使用。 前面说到import的引用默认都是相对于$GOPATH/src目录的。所以我们要想使用某个开源项目，就需要使用其相对于GOPATH/src的相对路径进行引用。（Go系统内建的项目除外） import引用的语法有两种方式 方式1，默认的引用方式，每个引用单独占一行， 如： 1import &quot;fmt&quot; 方式2，通过括号将所有的引用写在一个import中，每个引用单独占一行。通过这种方式，Go在格式化的时候也会将所有的引用按照字母的顺序进行排序，所以看起来特别的清晰。如： 1234import ( &quot;fmt&quot; &quot;math&quot; ) 比如，logrus项目结构是‘github.com/sirupsen/logrus’，所以在引用这个日志组件时，就要写成下面这样 1import &quot;github.com/sirupsen/logrus&quot; 如果只想使用logrus项目中的某一个package的话，可以单引用该package，而不用引用logrus全项目。这也是非常的方便。比如要使用logrus项目中’hook/syslog/syslog.go’，就可以像下面这样写import 1import &quot;github.com/sirupsen/logrus/hooks/syslog&quot; Go的引用还支持以文件路径的方式。如’./utils’引用当前目录下的util这个package时，就可以写成下面这样，当然按照项目路径的方式写才是最合适最规范的，并不推荐使用文件路径进行引用。 1import &quot;./utils&quot; 隐式引用Go的引用有一个特别另类的支持，那就是隐式引用，需要在引用前面加上_下划线标识。这种类型的引用一般会发生在加载数据库驱动的时候。如加载MySQL数据库驱动时。因为这些驱动在项目中并不会直接拿来使用，但不引用又不行。所以被称为隐式引用。 1import _ &quot;github.com/go-sql-driver/mysql&quot; package在引用的过程需要注意不能同时引用两个相同的项目，即不管项目的站点和项目所属，只要引用的项目package名称相同，都是不被允许的，在编译时会提示’XXX redeclared as imported package name’错误。但隐式引用除外。 12import &quot;encoding/json&quot;import &quot;github.com/gin-gonic/gin/json&quot;//!!! 不允许 !!! 但是能不能使用还要看这个package，就是这个package的可见性。 可见性可见行可以理解为Java 中的私有和公有的意思。以首字母大写的结构体、结构字段、常量、变量、函数都是外部可见的，可以被外部包进行引用。如”fmt”中的”Println”函数，其首字母大写，就是可以被其他package引用的，”fmt”中还有”free”函数，其首字母小写，就是不能被其他package引用。 但是不管对外部package是否可见，同一个package下的所有定义，都是可见并可以引用、使用的。 函数在Go语言中，函数的使用是最频繁的，毕竟要将代码写的清晰易懂嘛，而且好像所有的编程语言都有函数的概念（目前没听说过没有函数概念的语言） 在Go中，函数的定义支持多个参数，同样也支持多个返回值（比Java要厉害哦），多个参数和多个返回值之间使用英文逗号进行分隔。 同样与Java类似，Go的函数体使用‘{}’大括号进行包裹，但是，Go的定义更为严格，Go要求左大括号’{‘必须与函数定义同行，否则就会报错:’build-error: syntax error: unexpected semicolon or newline before {‘。 多个参数的函数定义 12345678func methodName(param1 type, param type2, param type3){ ...}//简写方式，可以将相同类型的参数并列定义func methodName(param1, param2 type, param3 type2) { ...} 有返回值的函数定义 函数返回值的定义可以只定义返回类型，也可以直接定义返回的对象。 定义了返回的对象后，就可以在函数内部直接使用该定义，避免了在函数中多次定义变量的问题。同时，在返回的时候也可以单单使用一个’return’关键字来代替 ‘return flag’这样的返回语句。需要注意返回值要不都定义返回对象，要不都不定义，Go不允许只定义部分函数返回对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//最简单的函数定义func methodName(){ ...}//仅定义返回的类型func methodName() bool{ ... return false}// 定义返回的对象+类型func methodName() (flag bool){ ... return}//定义多个返回类型func methodName()(bool, int) { ... return false, 0}//定义多个返回对象+类型func methodName()(flag bool, index int) { ... return}// !!! 不允许的定义 !!!func methodName()(bool, index int){ ... return}// !!! 不允许的定义 !!!func methodName(){ ... return} 在Go中有两个特别的函数，’main’函数和’init’函数。 ‘main’函数是程序的主入口，package main必须包含该函数，否则的话是无法运行的。在其他的package中，该函数之能是一个普通的函数。这点要特别注意。它的定义如下，不带也不能带任何的参数和返回值 123func main(){ ...} ‘init’函数是package的初始化函数，会在执行’main’函数之前执行。 同一个package中可以包含多个init函数，但是多个init函数的执行顺序Go并没有给出明确的定义，而且对于后期的维护也不方便，所以一个package中尽可能的只定义一个init函数比较合适。 多个package中的init函数，按照被import的导入顺序进行执行。先导入的package，其init函数先执行。如果多个package同时引用一个package，那其也只会被导入一次，其init函数也只会执行一次。 它的定义和main函数相同，也是不带也不能带任何的参数和返回值 123func init(){ ...} 数据类型在Go中，有 基本类型：int（整型）、float（浮点型）、 bool（布尔型）、 string（字符串类型） 集合类型：array（数组）、 slice（切片）、 map（map）、 channel（通道） 自定义类型： struct（结构体）、func（函数）等 指针类型 Go的集合类型并没有Java那么复杂，什么线程安全的集合、有序的集合都没有（全都需要自己实现^_^)! array和slice这两种集合都类似Java中的数组，他们无论在使用上都是一样的。以至于会经常忘记他们两个到底哪里不一样。其实真的是非常的细节，array是有长度的，slice是没有长度的。他们的区别就是这么小。 channel是Go中特有的一种集合，是Go实现并发的最核心的内容。与Unix中的管道也是非常的类似。 struct结构体简单理解就是对象了，可以自己定义自己需要的对象进行结构化的使用。和Java中的class不同，Java中函数是写在class中的，在Go中，struct的函数是要写在struct外的。结构体定义需要使用type关键字结合struct来定义。struct前的字段为新的结构体的名称。内部字段可以使用大写字母开头设置成对外部可见的，也可以使用小写字母开头设置成对外部不可见。格式如下： 12345678910type Student struct { Name string age int classId int}func main(){ var student Student = Student{Name:&quot;小明&quot;,age: 18, classId: 1} fmt.Printf(&quot;学生信息: 学生姓名: %s, 学生年龄: %d, 学生班级号: %d &quot;, student.Name, student.age, student.classId)} 针对结构体，Go还支持如下的定义 1type MyInt int 这是自定义的int类型，这样做的目的是，MyInt既包含了现有int的特性，还可以在其基础上添加自己所需要的函数。这就涉及到结构体的高级语法了，后续我们会详细的介绍。 Go的作者之前设计过C语言，或许这是Go同样有指针类型的原因吧，不过讲真的，Go中的指针比C中的指针要好理解的多。在定义时简单在类型前面加上*星号就行，使用时正常使用，不需要加星号。对其的赋值需要使用&amp;将其地址复制给该指针字段。 123456789var log *logrus.Loggerfunc init(){ log = logrus.New()}func main(){ log.Println(&quot;hello world&quot;)} 类型的内容还是很多的，不同的类型无论是在定义上还是使用上等都有不同的语境，后续会专门对其进行介绍。今天先介绍一下类型的定义。 Go中，无论是常量还是变量等的定义语法都是一样的。 常量的定义使用 const 关键字，支持隐式的定义，也可以进行多个常量的同时定义。 1234567891011const PI float = 3.1415926 //显式定义const SIZE = 10 //隐式定义//多个常量同时定义const ( LENGTH = 20 WIDTH = 15 HEIGHT = 20)//另一种写法的常量同时定义const ADDRESS, STREET = &quot;北京市朝阳区望京SOHO&quot;, &quot;望京街1号&quot; 变量的定义使用 var 关键字，同样支持隐式的定义和多个变量的同时定义 12345678910var word = &quot;hello&quot;var size int = 10var ( length = 20 width = 15 height = 20)var address, street = &quot;北京市朝阳区望京SOHO&quot;, &quot;望京街1号&quot; Go还支持在定义变量时把声明和赋值两步操作结合成一步来做。如下： 1size := length * width * height 这样省了定义变量这一步，代码更简洁，看着也更清晰，是比较推荐的方法。（常量不能这样用哦） 关键字及保留字为了保证Go语言的简洁，关键字在设计时也是非常的少，只有25个。 break case chan const continue default defer else fallthrough for func go goto if import interface map package range return select struct switch type var 当然，除了关键字，Go还保留了一部分基本类型的名称、内置函数的名称作为标识符，共计36个。 append bool byte cap close complex complex64 complex128 copy false float32 float64 imag int int8 int16 int32 int64 iota len make new nil panic print println real recover string true uint16 uint32 uint64 uint uint8 uintptr 另外，_下划线也是一个特殊的标识符，被称为空白标识符。所以，他可以像其他标识符那样接收变量的声明和赋值。但他的作用比较特殊，用来丢弃那些不想要的赋值，所以，使用_下划线来声明的值，在后续的代码中是无法使用的，当然也不能再付给其他值，也不能进行计算。这些变量也统一被称为匿名变量。 总结到这里，本篇内容讲解了Go中的package、func以及类型三部分的内容。也就是这三部分内容，构成了Go语言的基础结构。到这，咱们也能对 Hello World的代码有了一个清晰的认识。也可以尝试着动手写一写简单的例子来加深印象。下面是使用变量、常量、以及函数等基础结构来实现的程序，可以参考来理解。源码可以通过’github.com/souyunkutech/gosample’获取。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//源码路径：github.com/souyunkutech/gosample/chapter3/main.gopackage main //定义package为main才能执行下面的main函数，因为main函数只能在package main 中执行//简写版的import导入依赖的项目import ( &quot;fmt&quot; //使用其下的Println函数 &quot;os&quot; //使用其下的Stdout常量定义 &quot;time&quot; // 使用time包下的时间格式常量定义RFC3339 &quot;github.com/sirupsen/logrus&quot; //日志组件 &quot;github.com/souyunkutech/gosample/util&quot; //自己写的工具包，下面有自定义的函数统一使用)//声明log变量是logrus.Logger的指针类型，使用时不需要带指针var log *logrus.Logger// 初始化函数，先于main函数执行func init() { log = logrus.New() //使用logrus包下的New()函数进行logrus组件的初始化 log.Level = logrus.DebugLevel //将log变量中的Level字段设置为logrus下的DebugLevel log.Out = os.Stdout log.Formatter = &amp;logrus.TextFormatter{ //因为log.Formatter被声明为指针类型，所以对其赋值也是需要使用‘&amp;’关键字将其地址赋值给该字段 TimestampFormat: time.RFC3339, //使用time包下的RFC3339常量，赋值时如果字段与大括号不在一行需要在赋值后面添加逗号，包括最后一个字段的赋值！！！ }}//定义常量PIconst PI = 3.1415926//定义Student结构体，可以统一使用该结构来生命学生信息type Student struct { Name string //姓名对外可见（首字母大写） age int //年龄不能随便让人知道，所以对外不可见 classId int //班级也是}//main函数，程序执行的入口func main() { var hello = &quot;hello world&quot; //定义hello变量，省略了其类型string的声明 fmt.Println(hello) //使用fmt包下的Println函数打印hello变量 //多个变量的定义和赋值，使用外部函数生成 length, width, height := util.RandomShape() //使用其他package的函数 //多个变量作为外部函数的参数 size := util.CalSize(length, width, height) log.Infof(&quot;length=%d, width=%d, height=%d, size=%d&quot;, length, width, height, size) //使用日志组件logrus的函数进行打印长宽高和size var student = Student{Name: &quot;小明&quot;, age: 18, classId: 1} //声明学生信息，最后一个字段的赋值不需要添加逗号 log.Debugf(&quot;学生信息: 学生姓名: %s, 学生年龄: %d, 学生班级号: %d &quot;, student.Name, student.age, student.classId) //使用日志组件logrus的函数进行打印学生信息} 运行结果如下： 123hello worldINFO[0000] length=10, width=15, height=20, size=3000DEBU[0000] 学生信息: 学生姓名: 小明, 学生年龄: 18, 学生班级号: 1 如果还有不理解的内容可以通过搜云库技术群进行讨论或者留言，我们都会进行解答。 源码可以通过’github.com/souyunkutech/gosample’获取。 微信公众号 首发微信公众号：Go技术栈，ID：GoStack 版权归作者所有，任何形式转载请联系作者。 作者：搜云库技术团队出处：https://gostack.souyunku.com/2019/04/22/basic-knowledge","link":"/2019/04/22/basic-knowledge/"},{"title":"【跟着我们学Golang】之面向对象","text":"万物皆对象。学过Java编程的都知道Java是一门面向对象的语言，它拥有封装、继承和多态的特性。那可不可以说，拥有封装、继承和多态这一特性的语言就是面向对象的语言呢？仔细想来，也确实是这样的，因为封装、继承和多态这三个特征，并不是Java语言的特征，而是面向对象的三大特征。总结来看，所有包含封装、继承和多态者三大特征的语言都可以说是面向对象的语言。 那么Go语言是否是一门面向对象的语言呢？下面我们通过举例的方式针对封装、继承和多态这面向对象的三大特征分别进行解释。 封装Go中有struct结构体，通过结构体能够实现现实世界中对象的封装。如将学生封装成对象，除了学生的基础信息外，还需要一些学生的基础行为。 定义结构体的方式之前在基础结构中进行了简单的解释，并没有针对结构体的方法进行说明。这里先说明一下定义结构体的方法。 123func(alias type) func_name(parameter1 type, parameter2 type2)(ret1 type3, ret2 type4){ ...} 定义结构体的方法的语法与函数的语法类似，区别于普通函数，方法的定义在func后有一个括号(alias type)，指定方法的附属结构体，以方便通过结构体来进行方法的使用。 看到这里不免有些Java的同学觉得不太好接受，毕竟在Java中，对象的方法都是写在class中的，在Go中方法都是写在结构体外的。 所以可以总结一句，Go中的函数分为两类，一种是有附属于结构体的方法，一种是普通函数。附属于结构体的函数，在使用的过程中，需要结合结构体来使用，必须像Java那样先声明对象，然后结合对象才能使用。普通函数仅有是否可被外部包访问的要求，不需要先声明结构体，结合结构体来使用，开盖即食哈。 方法的结构体在指定时，alias别名可以随意设置，但是所属类型不能，（此处有坑）下面看一个例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport &quot;fmt&quot;type Student struct { Name string Learned []string}func (s Student) learnEnglish() { s.Learned = append(s.Learned, &quot;i&apos;m fine, thank you&quot;)}func (s *Student) learnMath() { s.Learned = append(s.Learned, &quot;1 + 1 = 2&quot;)}func (s *Student) whoAmI() { fmt.Println(&quot;your name is : &quot;, s.Name)}func (s Student) whoAmII() { fmt.Println(&quot;your name is : &quot;, s.Name)}func main() { s := Student{Name: &quot;jack&quot;} s.whoAmI() s.whoAmII() s.learnEnglish() //学英语 s.learnMath() //学数学 fmt.Println(s.Name, &quot;学过： &quot;) for _, learned := range s.Learned { fmt.Printf(&quot;\\t %s \\n&quot;, learned) }}/*运行结果：your name is : jackyour name is : jackjack 学过： 1 + 1 = 2---没有学过英语？？？*/ append为Go自带函数，向数组和slice中添加元素 这里有四个方法，两个打印名字的方法和两个学习的方法，区别点在于方法的所属类型一个是指针类型，另一个是非指针类型。 执行结果显示，打印名字的方法都正确输出了名字，但是学习英语和数学后，却显示只学过数学，没学过英语，这岂不是让我等学生的老师很头疼？ 这是为什么呢？ 这样就牵涉到了Go中的值拷贝和地址拷贝了。咱们先简单看一下值拷贝和地址拷贝。 值拷贝&amp;地址拷贝在Java中同样有值拷贝和地址拷贝的说法，学过Java的自然对Go的这点特性会比较容易理解。 在Go中虽然是都是值拷贝，但是在拷贝的过程中，拷贝的可能是变量的地址，或者是变量的值，不同的内容得到的结果当然是不一样的。 在函数定义参数时，如果参数类型是指针类型，则函数内修改了参数的内容，函数外同样会察觉到改参数的变化，这就是因为在调用该函数的时候，传递给该函数的值是一个地址，发生的是地址的拷贝，而这个地址指向的参数与函数外的变量是同一个，函数内修改了该地址的内容，相应的，函数外也会发生变化。这个还是通过例子比较好理解。 咱们继续让Jack学习不同的知识，在上一个代码中继续添加两个函数。 1234567891011121314151617181920212223242526272829303132333435363738func learnChinese(s *Student) { s.Learned = append(s.Learned, &quot;锄禾日当午，汗滴禾下土&quot;)}func learnPingPang(s Student) { s.Learned = append(s.Learned, &quot;ping pang&quot;)}func main() { s := Student{Name: &quot;jack&quot;} //初始化姓名 s.whoAmI() s.whoAmII() learnPingPang(s) //学习乒乓球 learnChinese(&amp;s) //学习中文 s.learnEnglish() //学英语 s.learnMath() //学数学 fmt.Println(s.Name, &quot;学过： &quot;) for _, learned := range s.Learned { fmt.Printf(&quot;\\t %s \\n&quot;, learned) }}/*运行结果：your name is : jackyour name is : jackjack 学过： 锄禾日当午，汗滴禾下土 1 + 1 = 2---没有学过英语？？？没有学过乒乓？？？*/ 例子中添加了两个函数learnChinese(s *Student)和learnPingPang(s Student)两个函数，分别接收带指针和不带指针的参数，下面执行的结果却显示Jack只学习了中文没学习乒乓，这也说明了learnPingPang(s Student)这个函数接收的参数发生了值拷贝，传递给该函数的值就是Student对象，而且是生成了一个新的Student对象，所以函数内发生的变化在函数外并不能感知。这个在平时的开发中还是需要特别的注意的。 看到这里应该就能理解为什么Jack没有学过英语了。(s Student) learnEnglish()这个函数中定义的所属类型是非指针类型，在使用时发生值拷贝，会生成新的Student对象，从而函数内部发生的变化并不会在函数外部有所感知。原来学英语的并不是Jack本人啊。 了解了如何定义方法之后就可以对封装有一个比较清晰的认识了，Go中的结构体定义对象和结构体方法定义对象的行为，可以满足封装要求了，也算是符合了封装的条件。下面来一个完整的封装例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package mainimport &quot;fmt&quot;type Class struct { Name string}type School struct { Name string}type Student struct { Name string Age int Height float64 Weight float64 SchoolInfo School ClassInfo Class Learned []string}func (s Student) learnEnglish() { // append为Go自带函数，向数组和slice中添加元素 s.Learned = append(s.Learned, &quot;i&apos;m fine, thank you&quot;)}func (s *Student) learnMath() { s.Learned = append(s.Learned, &quot;1 + 1 = 2&quot;)}func (s *Student) whoAmI() { fmt.Println(&quot;your name is : &quot;, s.Name, &quot; and your className is : &quot;, s.ClassInfo.Name, &quot; and your schoolName is : &quot;, s.SchoolInfo.Name)}func (s Student) whoAmII() { fmt.Println(&quot;your name is : &quot;, s.Name, &quot; and your className is : &quot;, s.ClassInfo.Name, &quot; and your schoolName is : &quot;, s.SchoolInfo.Name)}func learnChinese(s *Student) { s.Learned = append(s.Learned, &quot;锄禾日当午，汗滴禾下土&quot;)}func learnPingPang(s Student) { s.Learned = append(s.Learned, &quot;ping pang&quot;)}func main() { /* 定义对象时可以使用key:value的形式进行赋值，也可以使用value直接赋值，但是两中方式不能同时使用 使用key:value时，不需要注意顺序，可以直接赋值 使用value时，需要注意顺序，按照默认字段顺序进行赋值 ️注意：：如果最后一个字段与右大括号不在一行，需要在最后一个字段的赋值后加上逗号 */ s := Student{ Age: 18, Weight: 70, Height: 180, SchoolInfo: School{&quot;北大附中&quot;}, Name: &quot;jack&quot;, ClassInfo: Class{&quot;高二·8班&quot;}, } //初始化student对象 fmt.Println(&quot;学校： &quot;, s.SchoolInfo.Name) fmt.Println(&quot;班级： &quot;, s.ClassInfo.Name) fmt.Println(&quot;姓名： &quot;, s.Name) fmt.Println(&quot;年龄： &quot;, s.Age, &quot;岁&quot;) fmt.Println(&quot;身高： &quot;, s.Height, &quot;cm&quot;) fmt.Println(&quot;体重： &quot;, s.Weight, &quot;kg&quot;) s.whoAmI() s.whoAmII() learnPingPang(s) //学习乒乓球 learnChinese(&amp;s) //学习中文 s.learnEnglish() //学英语 s.learnMath() //学数学 fmt.Println(s.Name, &quot;学过： &quot;) for _, learned := range s.Learned { fmt.Printf(&quot;\\t %s \\n&quot;, learned) }}/*运行结果：学校： 北大附中班级： 高二·8班姓名： jack年龄： 18 岁身高： 180 cm体重： 70 kgyour name is : jack and your className is : 高二·8班 and your schoolName is : 北大附中your name is : jack and your className is : 高二·8班 and your schoolName is : 北大附中jack 学过： 锄禾日当午，汗滴禾下土 1 + 1 = 2---没有学过英语没有学过乒乓*/ 这里的Jack既有班级信息又有学校信息，既能学中文又能学英文。也算是把学生这个对象封装好了。 继承Java中，继承是说父子类之间的关系，子类继承父类，子类就拥有父类的部分功能。这个继承通过extend关键字就可以实现。在Go中，没有这个关键字，但是也可以做到相同的效果。使用的方式就是结构体的嵌套。我们继续使用学生这个例子进行讲解，现在将学生中的部分信息抽出到People这个结构体中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package mainimport &quot;fmt&quot;type Class struct { Name string}type School struct { Name string}type People struct { Name string Age int Height float64 Weight float64}func (p *People) SayHey() { fmt.Println(&quot;爱老虎油&quot;)}func (p *People) Run() { fmt.Println(p.Name, &quot;is running...&quot;)}func (p *People) Eat() { fmt.Println(p.Name, &quot;is eating...&quot;)}func (p *People) Drink() { fmt.Println(p.Name, &quot;is drinking...&quot;)}type Student struct { People //内嵌people Name string SchoolInfo School ClassInfo Class Learned []string}func (s *Student) SayHey() { fmt.Println(&quot;i love you&quot;)}func (s Student) learnEnglish() { // append为Go自带函数，向数组和slice中添加元素 s.Learned = append(s.Learned, &quot;i&apos;m fine, thank you&quot;)}func (s *Student) learnMath() { s.Learned = append(s.Learned, &quot;1 + 1 = 2&quot;)}func (s *Student) whoAmI() { fmt.Println(&quot;your name is : &quot;, s.Name, &quot; and your className is : &quot;, s.ClassInfo.Name, &quot; and your schoolName is : &quot;, s.SchoolInfo.Name)}func (s Student) whoAmII() { fmt.Println(&quot;your name is : &quot;, s.Name, &quot; and your className is : &quot;, s.ClassInfo.Name, &quot; and your schoolName is : &quot;, s.SchoolInfo.Name)}func learnChinese(s *Student) { s.Learned = append(s.Learned, &quot;锄禾日当午，汗滴禾下土&quot;)}func learnPingPang(s Student) { s.Learned = append(s.Learned, &quot;ping pang&quot;)}func main() { s := Student{ People: People{ Name: &quot;jack&quot;, //小名 Age: 18, Weight: 70, Height: 180, }, Name: &quot;jack·li&quot;, //大名 SchoolInfo: School{&quot;北大附中&quot;}, ClassInfo: Class{&quot;高二·8班&quot;}, } //初始化student对象 fmt.Println(&quot;学校： &quot;, s.SchoolInfo.Name) fmt.Println(&quot;班级： &quot;, s.ClassInfo.Name) fmt.Println(&quot;姓名： &quot;, s.Name) //打印时会打印大名 fmt.Println(&quot;年龄： &quot;, s.Age, &quot;岁&quot;) fmt.Println(&quot;身高： &quot;, s.Height, &quot;cm&quot;) fmt.Println(&quot;体重： &quot;, s.Weight, &quot;kg&quot;) s.whoAmI() s.whoAmII() learnPingPang(s) //学习乒乓球 learnChinese(&amp;s) //学习中文 s.learnEnglish() //学英语 s.learnMath() //学数学 fmt.Println(s.Name, &quot;学过： &quot;) //打印时会打印大名 for _, learned := range s.Learned { //打印学过的知识 fmt.Printf(&quot;\\t %s \\n&quot;, learned) } s.Eat() //直接使用内嵌类型的方法 s.Drink() //直接使用内嵌类型的方法 s.Run() //直接使用内嵌类型的方法 s.SayHey() //使用 Student 的sayHey fmt.Println(&quot;俺叫：&quot;, s.People.Name) //使用内嵌People的name打印小名 s.People.SayHey() //使用 内嵌People的SayHey}/*运行结果：学校： 北大附中班级： 高二·8班姓名： jack·li年龄： 18 岁身高： 180 cm体重： 70 kgyour name is : jack·li and your className is : 高二·8班 and your schoolName is : 北大附中your name is : jack·li and your className is : 高二·8班 and your schoolName is : 北大附中jack·li 学过： 锄禾日当午，汗滴禾下土 1 + 1 = 2 jack is eating...jack is drinking...jack is running...i love you俺叫： jack爱老虎油*/ 在这个例子中，Student内嵌了People，在定义Student对象时People结构体的字段单独定义在People对象中。但是在使用时，可以直接像s.Eat()，s.Run()，s.Height这样直接调用，也可以使用s.People.SayHey()和s.People.Name这样间接的调用。这就是嵌套的使用方法。 使用嵌套结构体的方式定义对象之后，就可以直接使用内嵌类型的字段以及方法，但是在使用时遇到相同的字段（Student的Name和People的Name）则直接使用字段时，使用的就是结构体的字段，而不是内嵌类型的字段，或者遇到相同的方法(Student的SayHey()和People的SayHey())则直接使用时，使用的就是结构体的方法，而不是内嵌类型的方法。如果要使用内嵌类型的字段或方法，可以在使用时指明内嵌结构体。这个有点像Java中的覆盖。所以有时在使用时需要注意要使用的是那个具体的字段，避免出错。 曲线救国也算是救国，Go通过内嵌结构体的形式，变相的实现了面向对象的继承，但是感觉总是比Java中的继承要差些什么。或许差的是继承的那些条条框框吧。 多态相同类型的对象表现出不一样的行为特征叫做多态。这个在Go中同样可以实现。通过interface就可以。 上节讲到interface是基础类型，这里咱们继续讲解interface作为接口的用法。 interface作为接口时，可以定义一系列的函数供其他结构体实现，但是只能定义函数，不能定义字段等。它的语法如下 123type name interface { func1([请求参数集]) [返回参数集]} Go中的接口在实现时可没有Java中的implement关键字，在实现接口的时候只需要实现接口中定义的全部的方法就可以认为是实现了这个接口，所以说Go的接口实现是一种隐式的实现，并不是直观上的实现。这点也是类似Java中的接口的，但是接口实现的这种关系并不是那么严格，如果通过ide在开发的过程中，能看到很多定义的方法实现了自己不知道的接口，不过放心，这是一种正常的现象，只要在使用的过程中稍加注意即可。 让咱们继续优化上面的例子来理解interface接口，还是看下面的例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package mainimport &quot;fmt&quot;type Class struct { Name string}type School struct { Name string}type Animal interface { Eat() Drink() Run()}//实现了Animal的三个方法，可认为*People实现了Animal接口type People struct { Name string Age int Height float64 Weight float64}func (p *People) SayHey() { fmt.Println(&quot;爱老虎油&quot;)}//实现Animal接口的Run方法func (p *People) Run() { fmt.Println(p.Name, &quot;is running...&quot;)}//实现Animal接口的Eat方法func (p *People) Eat() { fmt.Println(p.Name, &quot;is eating...&quot;)}//实现Animal接口的Drink方法func (p *People) Drink() { fmt.Println(p.Name, &quot;is drinking...&quot;)}//实现了Animal的三个方法，可认为*Student实现了Animal接口type Student struct { People //内嵌people Name string SchoolInfo School ClassInfo Class Learned []string}//实现Animal接口的Run方法func (s *Student) Run() { fmt.Println(s.Name, &quot;is running around campus&quot;)}//实现Animal接口的Eat方法func (s *Student) Eat() { fmt.Println(s.Name, &quot;is eating in the school cafeteria&quot;)}//实现Animal接口的Drink方法func (s *Student) Drink() { fmt.Println(s.Name, &quot;is drinking in the school cafeteria&quot;)}func (s *Student) SayHey() { fmt.Println(&quot;i love you&quot;)}func (s Student) learnEnglish() { // append为Go自带函数，向数组和slice中添加元素 s.Learned = append(s.Learned, &quot;i&apos;m fine, thank you&quot;)}func (s *Student) learnMath() { s.Learned = append(s.Learned, &quot;1 + 1 = 2&quot;)}func (s *Student) whoAmI() { fmt.Println(&quot;your name is : &quot;, s.Name, &quot; and your className is : &quot;, s.ClassInfo.Name, &quot; and your schoolName is : &quot;, s.SchoolInfo.Name)}func (s Student) whoAmII() { fmt.Println(&quot;your name is : &quot;, s.Name, &quot; and your className is : &quot;, s.ClassInfo.Name, &quot; and your schoolName is : &quot;, s.SchoolInfo.Name)}func learnChinese(s *Student) { s.Learned = append(s.Learned, &quot;锄禾日当午，汗滴禾下土&quot;)}func learnPingPang(s Student) { s.Learned = append(s.Learned, &quot;ping pang&quot;)}func main() { s := Student{ People: People{ Name: &quot;jack&quot;, //小名 Age: 18, Weight: 70, Height: 180, }, Name: &quot;jack·li&quot;, //大名 SchoolInfo: School{&quot;北大附中&quot;}, ClassInfo: Class{&quot;高二·8班&quot;}, } //初始化student对象 fmt.Println(&quot;学校： &quot;, s.SchoolInfo.Name) fmt.Println(&quot;班级： &quot;, s.ClassInfo.Name) fmt.Println(&quot;姓名： &quot;, s.Name) //打印时会打印大名 fmt.Println(&quot;年龄： &quot;, s.Age, &quot;岁&quot;) fmt.Println(&quot;身高： &quot;, s.Height, &quot;cm&quot;) fmt.Println(&quot;体重： &quot;, s.Weight, &quot;kg&quot;) s.whoAmI() s.whoAmII() learnPingPang(s) //学习乒乓球 learnChinese(&amp;s) //学习中文 s.learnEnglish() //学英语 s.learnMath() //学数学 fmt.Println(s.Name, &quot;学过： &quot;) //打印时会打印大名 for _, learned := range s.Learned { //打印学过的知识 fmt.Printf(&quot;\\t %s \\n&quot;, learned) } s.People.Eat() //直接使用内嵌类型的方法 s.People.Drink() //直接使用内嵌类型的方法 s.People.Run() //直接使用内嵌类型的方法 s.SayHey() //使用 Student 的sayHey fmt.Println(&quot;俺叫：&quot;, s.People.Name) //使用内嵌People的name打印小名 s.People.SayHey() //使用 内嵌People的SayHey var xiaoming, xiaohua Animal //大家都是动物，尴尬 //Student的指针类型实现了Animal接口，可以使用&amp;Student来给Animal赋值 xiaoming = &amp;s //jack的中文名叫xiaoming //People的指针类型实现了Animal接口，可以使用&amp;People来给Animal赋值 xiaohua = &amp;People{Name: &quot;xiaohua&quot;, Age: 5, Height: 100, Weight: 50} //xiaohua还小，每到上学的年级，不是学生 xiaoming.Run() //xiaoming在跑步 xiaohua.Run() //xiaohua在跑步 xiaoming.Eat() //xiaoming在吃东西 xiaohua.Eat() //xiaohua在吃东西 xiaoming.Drink() //xiaoming在吃东西 xiaohua.Drink() //xiaohua在吃东西}/*运行结果：学校： 北大附中班级： 高二·8班姓名： jack·li年龄： 18 岁身高： 180 cm体重： 70 kgyour name is : jack and your className is : 高二·8班 and your schoolName is : 北大附中your name is : jack and your className is : 高二·8班 and your schoolName is : 北大附中jack 学过： 锄禾日当午，汗滴禾下土 1 + 1 = 2jack·li is eating in the school cafeteriajack·li is drinking in the school cafeteriajack·li is running around campusi love you俺叫： jack爱老虎油jack·li is running around campusxiaohua is running...jack·li is eating in the school cafeteriaxiaohua is eating...jack·li is drinking in the school cafeteriaxiaohua is drinking...*/ 将People的三个方法抽象成接口Anmial，让People和Student两个结构都实现Animal的三个方法。声明xiaohua和xiaoming两个对象为Animal类型，给xiaohua声明一个还没上学People对象，给xiaoming声明一个已经上学的Student对象，最终得到了不一样的结果。 这里可能会有疑问，问什么将jack赋值给xiaoming时，给xiaoming的是&amp;s指针地址。这要从函数的实现说起。因为函数的实现指定的是指针形式的类型，在赋值时需要赋予指针类型的值才不会发生值拷贝，而且可以在使用的过程中修改对象中的值。但是在使用时可以不加指针直接使用，比如s.SayHey()就可以直接使用，不用转换为指针类型。 总结Go通过interface也实现了面向对象中多态的特征。现在总结来看，Go能够直接实现封装和多态，变相的实现继承的概念，这个在网络上被人称为是不完全的面向对象或者是弱面向对象，不过对于面向对象的开发，这已经够用了。 源码可以通过’github.com/souyunkutech/gosample’获取。 关注我们的「微信公众号」 首发微信公众号：Go技术栈，ID：GoStack 版权归作者所有，任何形式转载请联系作者。 作者：搜云库技术团队出处：https://gostack.souyunku.com/2019/05/13/oo","link":"/2019/05/13/oo/"}],"tags":[{"name":"学习资料","slug":"学习资料","link":"/tags/学习资料/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"}],"categories":[{"name":"资料索引","slug":"资料索引","link":"/categories/资料索引/"}]}